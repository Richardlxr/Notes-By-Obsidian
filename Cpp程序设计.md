# 程序设计 Cpp 复习笔记

## 一、 语言基础 / 表达式 / 运算符

### ✅【基础知识】

- **冯·诺依曼体系结构**：
    
    - **控制器**：==程序计数器（存放下一条指令地址）、指令寄存器（当前执行的指令地址）==等。
        
    - **运算器**：算数逻辑单元、寄存器。
        
    - **存储器**：主存（内存，断电丢失）、外存。
        
    - **设备**：输入/输出设备。
        
- **基本数据类型大小**（典型 64 位系统）：
    
    - char(1), bool(1)
        
    - short(2), int(4)
        
    - long(8, Win), long long(8)
        
    - float(4), double(8), long double(8, Win)
        
    - **指针**(8)
        
- **数组大小计算**：
    
    - 公式：个数 * 每个元素大小。
        
    - 注意：==字符串==数组需多算一个 \0。
        
- **算术运算规则**：
    
    - int / int：结果直接丢弃小数部分。
        
    - int / float 或 int + float：会发生**类型提升**（向高精度转换）。
        
- **逻辑运算符==短路特性==**：
    
    - && 左边为 false 时，右边表达式不再执行。
        
    - || 左边为 true 时，右边表达式不再执行。
        
- **位运算**：
    
    - 包含：按位与 &、或 |、异或 ^、取反 ~、左移 <<、右移 >>。
        
- **三目运算符**：
    
    - 格式：条件 ? 表达式1 : 表达式2。
        
    - 特性：仅执行其中一个分支。
        
- **数值极限**：
    
    - INT_MAX：约为 2.1\*10e9
	
- **运算符优先级**：
    
    1. 作用域 ::
        
    2. 成员访问 . ->
        
    3. 后缀 ++ --
        
    4. 一元运算 ! ~
        
    5. 算术 > 移位 > 关系 > 相等
        
    6. 位运算 > 逻辑 > 条件 > 赋值 > 逗号
        

---

### ⚠️【易错点 / 误解 / 辨析】

- **浮点数判等**：
    
    - 不可直接用 ==（如 0.1 + 0.2 == 0.3 为 false）。
        
    - 正确做法：==判断 abs(a - b) < 误差值。
        
- **赋值阶段截断**：
    
    - int = float：向 0 截断（如 -2.9 转为 -2）。
        
- **无符号数比较陷阱**：
    
    - int 与 unsigned 比较时，==int 转为 unsigned==。
        
    - 例子：==-1 < 1u 为 false==。
        
- **左移溢出**：
    
    - signed 类型左移可能导致符号位反转或未定义行为（UB）。
        
- **逗号运算符**：
    
    - 整个表达式的值为==**最后一个(最右边的）** 子表达式的值。
        

---

## 二、 控制流（if / for / while / switch）

### ✅【基础知识】

- **do-while**：
    
    - 即使条件不满足也会先执行一次循环体。
        
    - 支持多层嵌套。
        
- **switch 语句**：
    
    - case 后必须是==**唯一常量**。
        
    - default 仅在找不到匹配的 case 时执行。
        

---

### ⚠️【易错点 / 误解 / 辨析】

- **switch 贯穿（Fall-through）**：
    
    1. 如果一个 case 都找不到，就执行 default。
        
    2. 找到 case 后看是否有 break，没有的话下面的代码是要贯穿执行的==（按顺序！中途break了就break了）。
        
    3. default 可以省略不写。
        
- **switch 局部变量**：
    
    - case 后若有多个语句，除非用 {} 括起来，否则定义的局部变量作用域属于整个 switch 块，可能导致逻辑混乱。
        
- **switch 默认值位置**：
    
    - default 不一定要放在最后。
        
    - 若放在中间且末尾无 break，也会发生贯穿。
        
	
* ==**说人话就是说把case和default都看成标签就行了，switch跳到哪个标签就执行哪个，如果没有break，在下面的要接着执行。

---

## 三、 函数与作用域

### ✅【基础知识】

- **函数原型（声明）**：
    
    - 声明时可以省略形参名。
        
    - eg. int fun(int, double);
        
- **默认参数**：
    
    - 规则：必须==从右往左连续给出==。
        
    - 限制：只能在第一次声明时给出==一次==（后续定义不能再重复给）。
        
- **static 变量**：
    
    - 具有**静态存储期**：在程序运行期间一直存在。
        
    - 作用域：仍限制在定义它的块内（**不改变作用域**）。
        
- **==前向声明==**：
    
    - 在使用函数或类之前，必须先声明其存在。
        

---

### ⚠️【易错点 / 误解 / 辨析】

- **参数传递歧义**：
    
    - 重载函数时若配合默认参数，容易产生二义性报错。
        
    - 原则：只要不产生歧义就合法。
        
- **static 初始化**：
    
    - ==函数内 static 变量**只在第一次调用时初始化**，后续调用直接跳过初始化语句。
        
    - ==**举例**：
        
        codeC++
        
        ```
        void f(int a) {
            static int x = a;
            cout << x << endl;
        }
        // 调用:
        f(10); // 输出 10 (初始化)
        f(20); // 仍然输出 10 (不再初始化，忽略赋值)
        f(30); // 仍然输出 10
        ```
        
- **引用参数调用**：
    
    - 调用带引用参数的函数时，实参必须是**变量名**，不能是表达式。
        
    - 原因：引用必须绑定到一个==“已经存在的对象”。
        
- **函数返回局部引用**：
    
    - **严禁**返回局部变量的引用，因为函数结束时对象已销毁（无法绑定）。
        

---

## 四、 指针

### ✅【基础知识】

- **定义与分配**：
    
    - ==指针大小受 OS 位数影响（32位为4字节，64位为8字节）。
        
- **指针数组**：
    
    - 数组元素全为指针，如 char \*strPoints[10]。
        
- **多级指针**：
    
    - 指向指针的指针，如 int  \*\*q。
        
- ==**函数指针**：
    
    - 让函数“接收一个算法”，如 int (\*op)(int, int)。
	    `// 被传入的“算法函数”
	`int add(int a, int b) {
    ` a + b;
	`}

	`int sub(int a, int b) {
    `return a - b;
	`}

	`// 接收函数指针作为参数
	i`nt calc(int a, int b, int (*op)(int, int)) {
    `return op(a, b);   // 通过函数指针调用函数
	`}

	`int main() {
    `cout << calc(3, 4, add) << endl; // 7，调用的时候函数名变成函数指针
    `cout << calc(3, 4, sub) << endl; // -1，其实也可以int *fun(int,int);fun=sub;
    `return 0;
	`}
    
    - 推荐用 typedef 简化写法。
    
	`int* f();   // 指针函数（返回 int*）
	`int (*p)(); //  函数指针（指向函数）
`

---

### ⚠️【易错点 / 误解 / 辨析】

- ==**指针与 const 辨析**：
    
    1. const int \*p：**常量指针**，内容不可改，但 p 可改向。
        
    2. int \*const p：**指针常量**，p 的指向不可改，但内容可改。
        
    3. const int *const p：指向常量的指针常量，均不可改。
        
- **内存泄漏**：
    
    - 将指针指向新地址前，未释放旧的堆内存（delete）。
        
- **悬空指针**：
    
    - 执行 delete p 后，指针 p 仍然保存着已失效的地址。
        
    - ==对策：应及时设为 nullptr。
        
- **字符数组输出**：
    
    - cout << p：
        
        - ==若 p 指向字符数组：输出字符串直到遇到 \0。
            
        - ==若 p 指向普通数组：输出地址。
            

---

## 五、 引用

### ✅【基础知识】

- **本质**：变量的别名。
    
- **规则**：定义时必须==**立即初始化**且不可更改绑定。
    
- **主要用途**：
    
    1. 作为函数参数（减少拷贝开销）。
        
    2. 作为返回值（允许修改原对象）。
        
- **左值与右值**：
    
    - 左值：持久对象，可获取地址。
        
    - 右值：临时对象。
        

---

### ⚠️【易错点 / 误解 / 辨析】

- **非法引用**：
    
    - ==不存在：引用的引用、引用的数组、指向引用的指针（因为引用不分配独立内存）。
        
- **const 引用特殊规则**：
    
    - 普通引用不能绑定右值（字面量、表达式）。
        
    - ==const T& 可以绑定临时对象==（右值）。
	    
        原理：编译器实际上是
	    `int __tmp = 10;          // 编译器生成的临时对象
		`const int& r = __tmp;   // r 绑定到它
	    
- **返回引用的限制**：
    
    - 不可返回局部自动变量或临时表达式结果的引用。
        

---

## 六、 数组 / 字符串

### ✅【基础知识】

- **数组初始化**：
    
    - int a[5] = {}：所有元素置零。
        
    - 部分初始化：剩余元素自动置零。
	    
    * 注意：==全局/静态会自动置0,不用手动初始化
	    
- **C 风格字符串**：
    
    - 以 \0 结尾的字符数组。
        
    - ==常用函数：strlen（不计 \0）、strcpy、strcat(拼接）、strcmp、strncpy（char \*,char \*,int)（最多co n个，可能没加\0)。
        
- **std::string (C++ 类)**：
    
    - 支持：length()、size()注：这俩一样、at()（查越界）、substr()、find()。
        
- **string 遍历**：
    
    - ==支持 for(char c : s)、迭代器遍历、transform 转换大小写。
        

---

### ⚠️【易错点 / 误解 / 辨析】

- **数组名退化**：
    
    - 在传参==（注意按值传递的问题）==或取值表达式中，数组名退化为指向首元素的指针。
	    
        `void f(int arr[]) {
	    `cout << sizeof(arr) << endl;
		`}
		
		`int main() {
	    `int a[10];
	    `cout << sizeof(a) << endl; // 40
	    ==`f(a);                      // 8(此处数组名字退化成了指针（由于传参））`==
		`}
		
- **sizeof 陷阱**：
    
    - 在函数内部对形参数组用 sizeof，只得到指针大小（8），而非原数组总大小。
        
- **数组赋值限制**：
    
    - 数组名不能做左值，不可整体赋值（如 str1 = str2 是错误的）。
        
- **strncpy 填充行为**：
    
    - 源串短于 n：用 \0 填充剩余空间。
        
    - 源串长于等于 n：**不会自动补 \0**。
        
- **string 长度差异**：
    
    - ==std::string 内部`a.length()`可含 \0 且计入长度。
        
    - ==C 风格函数`strlen()`遇到第一个 \0 即停止。
        

---

## 七、 内存模型（栈 / 堆 / 静态区 / 常量区）

### ✅【基础知识】

- **栈区（Stack）**：局部变量、形参。由系统管理，后进先出。
    
- **堆区（Heap）**：通过 new 手动申请，delete 显式释放。空间最大。
    
- **静态存储区**：全局变量、静态变量。断电/程序结束前一直存在。
    
- **常量存储区**：字符串常量存放在此，只读。
    
- **new 失败处理**：
    
    - 返回 NULL。
        
    - 或通过 assert(p != 0)、exit(1) 处理。
        

---

### ⚠️【易错点 / 误解 / 辨析】

- **delete vs delete[]**：
    
    - ==释放数组必须使用 delete[]。
        
    - 否则析构顺序及内存回收可能出错。
        
- **字符串常量修改**：
    
    - ==char \*p = "abc"：指向常量区，**不可修改**。注意字符串一出现就在静态区分配了常量的空间
        
    - ==char arr[] = "abc"：数据在栈上，**可修改**。（因为创建了一个新的数组，这个数组是一个变量）
        
- **释放顺序**：
    
    - 构造顺序与析构顺序严格相反。
        

---

## 八、 类与对象

### ✅【基础知识】

- **访问控制**：
    
    - public：外部可见。
        
    - private：仅类内可见。
        
    - protected：类内及派生类可见。
        
- **this 指针**：
    
    - 成员函数的隐藏参数，指向当前对象。
        
    - **注意**：==静态成员函数没有 this 指针。
        
- **构造函数初始化列表**：
    
    - 在函数体执行前初始化成员。
        
    - **必须**在此初始化的场景：==常量成员、引用成员、无默认构造函数的成员对象。
        
- **组合类构造顺序**：
    
    - 按成员在类中**声明的顺序**执行，而非初始化列表的顺序。
        
- **静态成员**：
    
    - 不属于特定对象，属类共有。
        
    - ==**静态数据成员：类内声明，类外定义
        

---

### ⚠️【易错点 / 误解 / 辨析】

- **对象创建 vs 指针声明**：
    
    - A \*p; 只是定义指针，**不调用**构造函数。
        
- **默认拷贝构造行为**：
    
    - 执行逐成员的==**浅拷贝**。
        
    - 若含指针成员，会导致多个对象指向同一内存并触发二次析构崩溃。
        
- **常量成员函数**：
    
    - void f() const：内部不能修改任何非静态数据成员，只能调用==其他常量成员函数。
        
- **静态成员访问**：
    
    - ==静态成员函数**只能**访问静态数据成员。
        

---

## 九、 友元 / 运算符重载

### ✅【基础知识】

- **友元（Friend）**：
    
    - 授权非成员访问私有成员。
        
    - 特性：单向、不可传递、不可继承。
        
- **运算符重载限制**：
    
    - ==不可重载：. .* :: ?: sizeof。
        
    - ==不可创建新运算符。
        
- **重载形式**：
    
    - **成员函数重载**：第一个操作数必须是本类对象。
        
    - **非成员（友元）重载**：适合对称运算（如 Complex + double）。
        
- **特殊重载**：
    
    - operator()：使对象可像函数般调用（仿函数）。
        

---

### ⚠️【易错点 / 误解 / 辨析】

- ==**赋值 vs 拷贝构造**：
    
    - 对象已存在时：调用赋值运算符。
        
    - 对象正在创建时：调用拷贝构造。
        
- **前后置 ++ 区分**：
    
    - 前置：返回引用 A& operator++()。
        
    - ==后置：带 int 占位参数，返回副本 A operator++(int)。
        
- **流运算符重载**：
    
    - ==<< 和 >> **必须**作为非成员函数重载，否则第一个操作数（左操作数）不匹配。
        

---

## 十、 继承与多态

### ✅【基础知识】

- **继承方式**：
    
    - **Public**：基类 public 变派生类 public。
        
    - **Protected**：基类 public 变派生类 protected。
        
    - **Private**：基类成员在派生类中不可直接访问。
        
- **派生类构造**：
    
    - 不继承：构造、析构、赋值函数。
        
    - 调用顺序：**先构造基类，后构造派生类**。
        
- **虚函数（Virtual）**：
    
    - 实现**运行期多态**。
        
    - 底层：虚函数表（vtable）和虚指针（vptr）。
        
- **纯虚函数与抽象类**：
    
    - 格式：virtual void f() = 0;。
        
    - 特性：含有纯虚函数的类不能实例化。
        

---

### ⚠️【易错点 / 误解 / 辨析】

- **同名函数遮蔽**：
    
    - 派生类重定义基类同名函数（非虚）会遮蔽基类版本。
		
        `struct Base {
	    `virtual void f(int) {
        `cout << "Base::f(int)\n";
	    `}};
		
		`struct Derived : Base {
	    `void f(double) {
        `cout << "Derived::f(double)\n";
	    `}
		`};
	    ` 调用基类版：须加 Base::。
	    `Derived d;
		==`d.f(10);   // 被遮蔽了！，是derive（第一个查到的就是derive里面的），然后又不是virtual（参数类型不一样），所以直接就是derive里面的
		
        ==重要原理：成员函数的名字查找，  
		总是从“表达式的静态类型”对应的类开始。（就是接口类的类型）
		
- **对象切片（Slicing）**：
    
    - 按==值传递==派生类对象给基类时，派生类新增成员被舍弃，失去多态性。
        
- **虚析构函数必要性**：
    
    - 若类含虚函数，其析构函数应设为 virtual。（vitual继承需要函数名字和参数一模一样，因为本来就是函数的重写）
        
    - 目的：确保通过基类指针删除对象时，派生类部分能正确释放。
        （因为没有虚析构函数`Base* p = new Derived;`静态类型是Base，直接找到Base的析构就结束了。
        ==函数调用的顺序是编译器先通过名字表从静态类型开始找函数，找到就停下；然后如果这个函数是virtual，那么编译器再重新根据动态类型进行再匹配，找到真正应该找到的函数去调用）

---

## 十一、 模板 / 异常 / IO 流

### ✅【基础知识】

- **模板（Template）**：
    
    - 支持函数模板和类模板。
        
    - 可以含类型参数（typename T）和非类型参数（int N）。
	    `template<typename T, int N>
		`T arraySum(T (&arr)[N]) {   //这里的&非常重要！！！防止数组名字退化成指针就不知道大小了
	    `T sum = 0;
	    `for(int i = 0; i < N; ++i) sum += arr[i];
	    `return sum;
		`}
		
		`//注意一下格式
		`template<class T1,class T2>
        
- **异常处理**：
    
    - try 块抛出（throw），catch(...) 捕获。
        
	* 常见考点
		
	1. 类的创建者不必能够发现和处理该类使用过程中的所有异常。
		
	2. “处理了异常规格说明中指定的所有异常，程序就不会异常中止” ❌
		
    3. 区别异常和编译错误（可以捕获，程序能继续跑）、链接错误、runtime error（比如说除以0）的区别
	    
- **文件流（fstream）**：
    
    - 模式：ios::in, ios::out, ios::app 等。
        
    - ~~检查：操作前应检查 !fin。
        

---

### ⚠️【易错点 / 误解 / 辨析】

- **模板特化**：
    
    - 函数模板**仅支持完全特化**，不支持部分特化。（要重写你就重写整个函数
        
- **异常规格说明**：
    
    - throw(A, B) 声明可能抛出的异常。
        
    - 若抛出规格之外的异常，会调用 std::unexpected() 导致程序终止。
        
- **cin 缓冲区**：
    
    - ==cin 不会丢弃最后一个换行符。
        

---

## 十二、 杂项 & 边角考点

- **枚举（Enum）本质**：
    
    - ==本质是整数，默认从 0 开始。
        
    - 手动赋值项后，后续项自动递增。
        
- **结构体内存对齐**：
    
    - ==总大小必须是其**最大成员对齐要求**的整数倍。
        
- **模块化设计限制**：
    
    - 非 inline 的全局变量或函数定义不应放头文件，否则多文件包含会导致**重复定义**错误。
        
- **extern "C" 与 extern**：
    
    - extern int a; 是声明而非定义。
        
    - extern int a = 5; 即使带 extern 也是**定义**。
        
- **宏保护**：
    
    - \#ifndef 只能防止**同一个** .cpp 文件内的重复包含。
        
- **编译器 vs 链接器**：
    
    - 单个 .cpp 展开编译通为“编译器安全”。
        
    - 多个 .o 文件拼接不冲突为“链接器安全”。
        
- **退出机制**：
    
    - return：退出当前函数。
        
    - exit()：退出整个进程。
	
- **记住
	
	* 看到&&和||