## 一、语言基础 / 表达式 / 运算符

### ✅【基础知识】
- 冯·诺依曼体系结构：包含控制器（程序计数器、指令寄存器等）、运算器（ALU、寄存器）、存储器（主存、外存）以及输入/输出设备。  
- 基本数据类型大小（典型 64 位系统）：char(1), bool(1), short(2), int(4), long(8, Win), long long(8), float(4), double(8), long double(8, Win), 指针(8)。  
- 数组大小计算：个数 * 每个元素大小。注意==字符串==数组需多算一个 \0。  
- 算术运算规则：int / int 结果丢弃小数；int / float 或 int + float 会发生类型提升。  
- 逻辑运算符==短路特性==：&& 左边为 false 或 || 左边为 true 时，右边表达式不再执行。  
- 位运算：包含按位与 &、或 |、异或 ^、取反 ~、左移 <<、右移 >>。  
- 三目运算符：条件 ? 表达式1 : 表达式2，仅执行其中一个分支。  
- INT_MAX：约为 2.1×10^9。  
- 运算符优先级：作用域 :: > 成员访问 . -> > 后缀 ++ -- > 一元运算 ! ~ > 算术 > 移位 > 关系 > 相等 > 位运算 > 逻辑 > 条件 > 赋值 > 逗号。

### ⚠️【易错点 / 误解 / 辨析】
- 浮点数判等：不可直接用 ==（如 0.1 + 0.2 == 0.3 为 false），需判断 abs() < 误差。  
- 赋值阶段截断：int = float 向 0 截断（如 -2.9 转为 -2）。  
- 无符号数比较陷阱：int 与 unsigned 比较时，==int 转为 unsigned==。例如==-1 < 1u 为 false==
- 左移溢出：signed 左移可能导致符号位反转或未定义行为（UB）。  
- 逗号运算符：整个表达式的值为最后一个子表达式的值。

---

## 二、控制流（if / for / while / switch）

### ✅【基础知识】
- do-while：即使条件不满足也会先执行一次循环体。支持多层嵌套。  
- switch 语句：case 后必须是唯一常量，default 仅在找不到匹配 case 时执行。

### ⚠️【易错点 / 误解 / 辨析】
- switch 贯穿（Fall-through）：
	
	如果一个case都找不到，就执行default；
	
	找到case看有没有break，没有的话default是要贯穿执行的；
	
	
	default可以省略不写

- switch 局部变量：case 后多个语句除非用 {} 括起来，否则定义局部变量算在switch的作用域里面。  

- switch 默认值位置：default 不一定要放最后，若放中间且无 break 也会贯穿。

---

## 三、函数与作用域

### ✅【基础知识】
- 函数原型：声明时可以省略形参名。  
- 默认参数：必须从右往左连续给出，且只能在第一次声明时给出一次。  
- static 变量：具有静态存储期，在程序运行期间一直存在，但作用域仍限制在定义它的块内（不改变作用域）。  
- ==前向声明==：在使用函数或类之前必须先声明其存在。

### ⚠️【易错点 / 误解 / 辨析】
- 参数传递歧义：重载函数时若配合默认参数，容易产生二义性报错。  （原则：不会歧义就合法）
- static 初始化：函数内 static 变量只在第一次调用时初始化，后续调用直接跳过初始化语句。  
- 引用参数调用：调用带引用参数的函数时，实参必须是变量名，不能是表达式。  
- 函数返回局部引用：严禁返回局部变量的引用，因为函数结束时对象已销毁。

---

## 四、指针

### ✅【基础知识】
- 定义与分配：指针大小受 OS 位数影响（32位为4字节，64位为8字节）。  
- 指针数组：数组元素全为指针，如 char *strPoints。  
- 多级指针：指向指针的指针，如 int **q。  
- 函数指针：通过 int (*op)(int, int) 让函数“接收一个算法”。推荐用 typedef 简化写法。

### ⚠️【易错点 / 误解 / 辨析】
- 指针与 const 辨析：  
  - const int *p：常量指针，不可通过 p 修改内容，但 p 可改向。  
  - int *const p：指针常量，p 的指向不可改，但内容可改。  
  - const int *const p：指向常量的指针常量，均不可改。  
- 内存泄漏：将指针指向新地址前未释放旧的堆内存。  
- 悬空指针：执行 delete p 后，指针 p 仍然保存着已失效的地址。应及时设为 nullptr。  
- 字符数组输出：cout << p 若 p 指向字符数组，会输出字符串直到 \0；若指向普通数组则输出地址。

---

## 五、引用

### ✅【基础知识】
- 本质：变量的别名，定义时必须立即初始化且不可更改绑定。  
- 主要用途：作为函数参数（减少拷贝开销）或返回值（允许修改原对象）。  
- 左值与右值：左值是持久对象，可获取地址；右值是临时对象。

### ⚠️【易错点 / 误解 / 辨析】
- 非法引用：不存在引用的引用、引用的数组或指向引用的指针（引用不分配独立内存）。  
- const 引用特殊规则：普通引用不能绑定右值（如字面量、表达式结果），但 const T& 可以绑定临时对象。  
- 返回引用的限制：不可返回局部自动变量或临时表达式结果的引用。

---

## 六、数组 / 字符串

### ✅【基础知识】
- 数组初始化：int a = {} 会将所有元素置零。若只部分初始化，剩余元素自动置零。  
- C 风格字符串：以 \0 结尾的字符数组。常用函数：strlen（不计 \0）、strcpy、strcat、strcmp、strncpy。  
- std::string：C++ 类，支持 length()、size()、at()（查越界）、substr()、find() 等。  
- string 遍历：支持 for(char c : s)、迭代器遍历以及 transform 转换大小写。

### ⚠️【易错点 / 误解 / 辨析】
- 数组名退化：数组名在传参或取值表达式中退化为指向首元素的指针。  
- sizeof 陷阱：在函数内对形参数组用 sizeof 只得到指针大小（8），而非原数组总大小。  
- 数组赋值限制：数组名不能做左值，不可整体赋值（如 str1 = str2 错误）。  
- strncpy 填充行为：若源串短于 n，会用 \0 填充剩余空间；若源串长于等于 n，则不会自动补 \0。  
- string 长度差异：std::string 内部可含 \0 且计入长度；C 风格函数遇到第一个 \0 即停止。

---

## 七、内存模型（栈 / 堆 / 静态区 / 常量区）

### ✅【基础知识】
- 栈区（Stack）：局部变量、形参。由系统管理，后进先出。  
- 堆区（Heap）：程序员通过 new 手动申请，delete 显式释放。空间最大。  
- 静态存储区：全局变量、静态变量。断电前一直存在。  
- 常量存储区：字符串常量存放在只读存储区。  
- new 失败处理：返回 NULL 或通过 assert(p != 0)、exit(1) 处理。

### ⚠️【易错点 / 误解 / 辨析】
- delete vs delete[]：释放数组必须使用 delete[]，否则析构顺序及内存回收可能出错。  
- 字符串常量修改：char *p = "abc" 指向常量区，不可修改。char arr[] = "abc" 在栈上，可修改。  
- 释放顺序：构造顺序与析构顺序严格相反。

---

## 八、类与对象

### ✅【基础知识】
- 访问控制：public（外部可见）、private（类内可见）、protected（类内及派生类可见）。  
- this 指针：成员函数的隐藏参数，指向当前对象。静态成员函数没有 this 指针。  
- 构造函数初始化列表：在函数体执行前初始化成员。常量成员、引用成员、无默认构造函数的成员对象必须在此初始化。  
- 组合类构造顺序：按成员在类中声明的顺序执行，而非初始化列表的顺序。  
- 静态成员：不属于特定对象，属类共有。静态数据成员必须在类外定义和初始化。

### ⚠️【易错点 / 误解 / 辨析】
- 对象创建 vs 指针声明：A *p; 只是定义指针，不调用构造函数。  
- 默认拷贝构造行为：执行逐成员的浅拷贝。若含指针成员，会导致多个对象指向同一内存并触发二次析构崩溃。  
- 常量成员函数：void f() const 内部不能修改任何非静态数据成员，只能调用其他常量成员函数。  
- 静态成员访问：静态成员函数只能访问静态数据成员。

---

## 九、友元 / 运算符重载

### ✅【基础知识】
- 友元（Friend）：授权非成员函数或类访问私有成员。单向、不可传递、不可继承。  
- 运算符重载限制：不可重载 . .* :: ?: sizeof 等。不可创建新运算符。  
- 重载形式：  
  - 成员函数重载：第一个操作数必须是本类对象。  
  - 非成员（友元）重载：适合实现对称运算，如 Complex + double。  
- 特殊重载：operator() 使对象可像函数般调用（仿函数）。

### ⚠️【易错点 / 误解 / 辨析】
- 赋值 vs 拷贝构造：对象已存在时调用赋值运算符；对象正在创建时调用拷贝构造。  
- 前后置 ++ 区分：前置返回引用 A& operator++()；后置带 int 占位参数并返回副本 A operator++(int)。  
- 流运算符重载：<< 和 >> 必须作为非成员函数重载，否则第一个操作数不匹配。

---

## 十、继承与多态

### ✅【基础知识】
- 继承方式：  
  - Public：基类 public 变派生类 public。  
  - Protected：基类 public 变派生类 protected。  
  - Private：基类成员在派生类中不可直接访问。  
- 派生类构造：派生类不继承基类构造/析构/赋值函数，但必须调用基类构造。先构造基类，后构造派生类。  
- 虚函数（Virtual）：通过虚函数表（vtable）和虚指针（vptr）实现运行期多态。  
- 纯虚函数与抽象类：virtual void f() = 0;。含有纯虚函数的类不能实例化。

### ⚠️【易错点 / 误解 / 辨析】
- 同名函数遮蔽：派生类重定义基类同名函数（非虚）会遮蔽基类版本。若需调用基类版，须加 Base::。  
- 对象切片（Slicing）：按值传递派生类对象给基类时，派生类新增成员被舍弃，失去多态性。  
- 虚析构函数必要性：若类含虚函数，其析构函数应设为 virtual，确保通过基类指针删除对象时派生类部分能正确释放。

---

## 十一、模板 / 异常 / IO 流

### ✅【基础知识】
- 模板（Template）：支持函数模板和类模板。template<typename T, int N> 可同时含类型和非类型参数。  
- 异常处理：try 块抛出（throw），catch(...) 捕获。匹配遵循严格类型一致，支持继承链匹配。  
- 文件流（fstream）：ios::in, ios::out, ios::app 等模式。操作前应检查 !fin。

### ⚠️【易错点 / 误解 / 辨析】
- 模板特化：函数模板仅支持完全特化，不支持部分特化。  
- 异常规格说明：throw(A, B) 声明可能抛出的异常类型。若抛出规格之外的异常，会调用 std::unexpected() 导致程序终止。  
- cin 缓冲区：cin 不会丢弃最后一个换行符。

---

## 十二、杂项 & 边角考点

**「零散知识点 / 边角考点 / 冷门但存在」**
- 枚举（Enum）本质：本质是整数。默认从 0 开始。手动赋值项后，后续项自动递增。  
- 结构体内存对齐：结构体总大小必须是其最大成员对齐要求的整数倍。  
- 模块化设计限制：非 inline 的全局变量或函数定义不应放头文件，否则多文件包含会导致重复定义错误。  
- extern "C" 与 extern：extern int a; 是声明而非定义。extern int a=5; 即使带 extern 也是定义。  
- 宏保护：#ifndef 只能防止同一个 .cpp 文件内的重复包含。  
- 编译器 vs 链接器：单个 .cpp 展开编译通为“编译器安全”；多个 .o 文件拼接不冲突为“链接器安全”。  
- 退出机制：return 退出函数；exit() 退出整个进程。
